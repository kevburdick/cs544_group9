/* * This class is the state machine for protocol and the public interface  * */ import message.Connect;import message.Message;import message.AckConnect;import message.Contents;import message.Open;import message.Move;import message.ReqLock;import message.Release;import message.ReqContents;import message.Sync;import message.Edit;import message.Close;/** Main program class for the client application  */public class CTP{    static short state;    static short clientID;    static Transport transport;    final short VERSION =1;    final int PORT = 5449;    public CTP(String host) {        state = INIT_STATE;        transport = new Transport(host,PORT); 	 }        /**      * Method connects to the server      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int Connect()     {        //request        if(state == INIT_STATE) {             Connect connect = new Connect(VERSION);            transport.sendRequest(connect.getbyteArray());            state = VERSION_STATE;        }         else {           return -1; //invalid request for this state		  }        //response        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.ACKCONNECT_TYPE) {            AckConnect ackMsg = (AckConnect)msg;            clientID = ackMsg.getClientID();            state = CONNECTED_STATE;            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }	 }       /**      * Method Opens a file on the server      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int Open() 	 {        //request        if(state == CONNECTED_STATE) {             Open openMsg = new Open(clientID,3214);            transport.sendRequest(openMsg.getbyteArray());             state = OPENING_STATE;        }         else {           return -1; //invalid request for this state		  }        //response        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.ACKOPEN_TYPE) {            state = OPEN_STATE;            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }    }    /**      * Method request the file lock from the server      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int ReqLock() 	 {        //request        if(state == OPEN_STATE) {             ReqLock rlock = new ReqLock(clientID);            transport.sendRequest(rlock.getbyteArray());             state = WAIT_LOCK_STATE;        }         else {           return -1; //invalid request for this state		  }        //response        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.ACKLOCK_TYPE) {            state = LOCKED_STATE;            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }    }    /**      * Method requests the file lock be release from the server     * requires that this client have ownership of the lock      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int ReleaseLock() 	 {        //request        if(state == LOCKED_STATE) {             Release rel = new Release(clientID);            transport.sendRequest(rel.getbyteArray());        }         else {           return -1; //invalid request for this state		  }        //response        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.SERVRELEASE_TYPE) {            state = OPEN_STATE;            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }    }    /**      * Method sends a MOVE message to the server indicating the new position      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int Move(long cursorPos) 	 {        //request        if(state == OPEN_STATE || state == LOCKED_STATE ||            state == WAIT_LOCK_STATE) {             Move move = new Move(clientID,cursorPos);            transport.sendRequest(move.getbyteArray());        }         else {           return -1; //invalid request for this state		  }        //response        //this seems to have no reponse        return 1;    }        /**      * Method requests the contents of a file     * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    //FIXME this should return an object for data and status    public int ReqContents(int cursorLoc, int size) 	 {        //request        if(state == OPEN_STATE || state == WAIT_LOCK_STATE) {             ReqContents req = new ReqContents(clientID,cursorLoc,size);            transport.sendRequest(req.getbyteArray());        }         else {           return -1; //invalid request for this state		  }        //response - does not change state        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.CONTENTS_TYPE) {            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }    }    /**      * Method sends a Sync message to the server request a status message     * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int Sync() 	 {        //request        if(state == OPEN_STATE || state == LOCKED_STATE ||            state == WAIT_LOCK_STATE) {             Sync sync = new Sync(clientID);            transport.sendRequest(sync.getbyteArray());        }         else {           return -1; //invalid request for this state		  }        //response - does not change state        byte[] buff = transport.getResponse();         Message msg = Message.makeMessage(buff);        if(msg.getType() == Message.CONTENTS_TYPE) {            return 1;		  }        else {           //FIXME need to handle error message           return 0; //failed response from server		  }    }    /**      * Method sends a Edit message to the server      * returns 1 on success     *         0 on a failed response from server     *        -1 on a invalid request to the state machine      */    public int Edit(byte action, int cursorLoc, byte[] data) 	 {        //request        if(state == OPEN_STATE || state == LOCKED_STATE ||            state == WAIT_LOCK_STATE) {             Edit edit = new Edit(clientID,action,cursorLoc, data);            transport.sendRequest(edit.getbyteArray());        }         else {           return -1; //invalid request for this state		  }        //response - does not change state        while(true) {		     byte[] buff = transport.getResponse(); 		     Message msg = Message.makeMessage(buff);		     if(msg.getType() == Message.ACKEDIT_TYPE) {		         return 1;			  }		     else {               		        //FIXME need to handle error message		        return 0; //failed response from server			  }		  }    }    /**      * Method sends a Edit message to the server      * returns 1 on success     */    public int Close() 	 {        //request        Close close = new Close();        transport.sendRequest(close.getbyteArray());        //this seems to have no reponse        close();        return 1;    }   /**     * Method closes the trnasport layer     */    private void close()    {        //close socket        transport.close();    }        private static final short INIT_STATE = 1;    private static final short VERSION_STATE = 2;   	 private static final short CONNECTED_STATE = 3;	 private static final short OPENING_STATE = 4;	 private static final short OPEN_STATE = 5;	 private static final short WAIT_LOCK_STATE = 6;    private static final short LOCKED_STATE = 7;}    